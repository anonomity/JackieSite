---
path: "/unity-progress"
date: "28/09/2021"
title: "Important Unity Concepts"
category: "GameDev"
tags: []
exerpt: "Unity"
status: "ðŸŒ±"
---
import model from "./model.jpg"
import compare from "./compare.png"
import SideNote from "../../../components/blogComponents/SideNote/SideNote.tsx";
import MediumPic from "../../../components/blogComponents/Pictures/MediumPic";



## Hypatia 
Hello Everyone, I'm a programmer who loves video games and as of March 2021 I started making my own games and learning Unity. What is Hypatia you might ask? Well it's a game I've been working on since May 2021
and its a 2D action rpg, made with pixel art. Some features it includes is Greek Mythology, Ancient Athens, and skill trees, and philosophy. I want to make an exciting game that
users will have fun playing, but I also want people to learn along the way, that's why I'm making the game very accurate and drawing the scenes based on what it really looked like. 
I visited Athens, Greece in June 2021 and got a first hand look at what I'm dealing with. The Acropolis Museum helped me tremendously with creating models of the city at different points of time.
Although accuracy is very important to me, I have to twist the truth a bit to keep things interesting, thats why you might find some philosophers walking the same street that are from somewhat 
different generations! As of now I'm developing the art, programming and music all by myself but who knows what will change! 

<MediumPic img={model} alt="ancient athens model" />  

## Unity 
Some concepts I've ran into while learning unity, before this projects I haven't had too much experience with statically typed languages, I used mostly javascript and python, though I 
had one class in University on Java. It was a tough decision to decide which route to take to build my 2d game. Ultimately I ended up going with Unity probably more due to familiarity 
and legacy. I had a couple of friends in University who had made little games here and there and all of them used Unity. I was also hesitant with how much could get done with a 
dynamic language like Godot, unity being written with C# meant that it was static, and in my understanding, static languages can handle bigger loads of information more efficiently.
Through the 8 months of using unity at the time of writting this article, there are some new concepts I've learned and I've seen becoming important with Unity, and OOP.


### Important Unity / C# / OOP Concepts

1. Scriptable Objects
2. Singleton design pattern
3. Delegate
4. Event System 
5. Monobehavior
6. State Machines




as a sidenote I've realized I had to stop using arrays as much in c# because Lists are the superior data structure.

## Scriptable Objects
- Smart data containers that can hold values that also exist outside of play mode
- Globally accessible and scene independent
- Act as layers to expose and reuse common functionalities
- you can edit scriptable objects while in playmode
- Using Scriptable Object as Enum States


<img src={compare} alt="difference between scriptable vs mono" />  

so the only new methode you get is OnDestoy() and you don't have access to the game loop through functions like
update and start

### Scriptable Objects Vs Monobehaviors
Scriptable objects can not be attached to components as a gameobject instead they are created a project asset 
files



Monobehaviors are always live on a game object, so by design their bound to an instance of a gameobject
and because of that when you want to access the data for the prefab, each instance will have a copy of the transform
and the gameobject which is a waste of space. 
- moral of the story, if you prefab doesn't need access to gameobject or transform, and you want to save
memory, you should use Scriptable Objects instead of Monobehaviors

### Uses 

- using a scriptable object as an event relayer that listens to unity's input system so that events can subscribe to it whenever
 the input is detected so that you don't need to keep program different listeners. 



[youtube video on scriptable objects](https://www.youtube.com/watch?v=PVOVIxNxxeQ)



## Singleton

## Delegate

## Event System

This concept is very interesting. You could produce a whole game without using this, but what it does, *is it makes your code a lot better*. The reason 
why you *should* use the Event System is because it allows you to compartmentalize logic more efficiently. Your Front-end Code should be separate from the
backend, with the event system you can write the backend once and have subscribers attached to it. These subscribers do not effect the backend code
at all, the backend doesn't need to know who these subscribers are or what they're doing. For instance, I can have backend code that sets off an event when
the user clicks a particular key, lets say "TAB", when the user hits tab, the event is fired, and either no variables or some variables are passed to that event. 
The subscribers can activate when that event is fired and you can create methods inside the script with the subscribers to perform certain methods
when that event is activated.



## Monobehavior 

Honestly I never though about how important it was to take a dive into Monobehavior until writing this article. Monohevaior is 
what **most** of your scripts will inherit from. 

<SideNote title="Inheritance" text="Inheritance is an object oriented programming concept, it's what happens when one script gets 
retrieved methods / variables  from anothers script, for example lets say we have an Animals scripts and in this script we have the method 
**breathe**, if I make another script Dog that inherits from Animal, the dog will be able to use the method breathe." />

When I looked into the Monobehavior I notice some Methods I had no idea that existed and could be very useful, for instance, 
OnMouseDrag, OnMouseDown, and OnMouseEnter, these methods can help when dealing with input from the mouse to develop some really intricate
systems.

## State Machines

I've been unexcusably hesitant to try out Unity State Machines. I finally threw in the towel
and got cracking on it when I was programming the AI for an enemy in my game.

The first thing I realized was that you create State Machine Scripts differently from normal scripts
in unity. In order to create State Machine (SM) script, you must open the animator tab, and click on 
an animation, and in the inspector window click [Add Behavior] once you open up the created script
you'll realize that the script no longer inherits from MonoBehavior but from StateMachineBehaviour. 
Another feature is this has a bunch of methods that are commented out. OnStateEnter(), 
OnStateUpdate(), OnStateExit(), OnStateMove() and OnStateIK().
For now the first 3 are the most important and are pretty self explanatory. 
The first [OneStateEnter] is called once the animation state is entered, the second [OnStateUpdate] is a loop that is 
called at each Update frame except for the first and last frame. Finally [OnStateExit] is called on the last update frame when a state machine evaluates this state.

I don't know about you but I've used way too many Coroutines and unnecessary code controlling when the state changes, and when to change using methods like,
animator.GetBool("state") or animator.SetBool("state", false) peppered throughout my code. Its nice to have a central place that controls the animation state just
to clean up and compartmentalize things. 

Another neat thing about state machines is that in the function it already supplys you with that gameobjects animator so you don't need to fetch it in a variable. 

For my first use case, I used state machine to control the enemy in my game through 4 state, 

1. Patrolling State - When the enemy chooses a random location and walks to that random position.
2. Follow State - when the enemy detects me and starts following me.
3. Attack State - after the enemy follows me and is within range to attack.
4. Idle State - after the enemy gets to the patrol states random position, and it waits in that position for around 4 seconds.





